package main

import (
	"fmt"
)
//主要思路：
//如果用递归的话很容易因为情况太多超时
//所以使用动态规划
//目前已知一个邻接矩阵，现在只需要计算邻接矩阵times次方后的第一个元素
//那么问题就可以简化为邻接矩阵第一行反复乘邻接矩阵，最后一次计算该行和邻接矩阵第一列的乘积
func main() {
	var (
		peoNum int
		times  int
	)
	fmt.Scanf("%d %d", &peoNum, &times)
    //创建一个两行的二维切片（第一行记录传递i次之后球在第一个人手上的情况，第二行记录在其他人手上的情况）
	p := make([][]int, 2)
	for i, _ := range p {
		p[i] = make([]int, 16)
	}
    //第一次传递时，球必定在其他人手上，所以p[0][0]=0,p[1][0]为peoNum-1
	p[1][0] = peoNum - 1
	p[0][0] = 0
    //通过递推公式来推出经过times次传递后球在第一个人手上的情况
	for i := 1; i < times; i++ {
        //由邻接矩阵的特点，当前次球在第一个人手上的情况等于上一次球在其他人手上的情况
        //（因为邻接矩阵第一列第一个元素为0，其余元素均为1）
		p[0][i] = p[1][i-1]
        //由邻接矩阵的特点，当前次的所有情况等于上一次的所有情况的peoNum-1倍
        //（因为上一次球在每个人手上的情况通过邻接矩阵的运算都被计算了peoNum次）
        //那么当前次球在其他人手上的次数就是(p[0][i-1]+p[1][i-1])(上一次的所有情况)*（peoNum-1）-p[0][i]（减去当前次在第一个人手上的情况）
		p[1][i] = (p[0][i-1]+p[1][i-1])*(peoNum-1) - p[0][i]
	}
    //注意到传递次数与切片下表差一，第1次传球对应切片列下表0
	fmt.Printf("%d", p[0][times-1])
}
